Wish the web server handles route {/cnc$} with handler {
    html {
<html>
  <body>
    <script>
     let ws;
     function redisplayCalibrationTag(x = 100, y = 100, size = 50) {
       ws.send(`
          Retract /anyone/ wishes to display CNC calibration tag with /...options/
          Assert $chan wishes to display CNC calibration tag with \\
            id 48600 x ${x} y ${y} size ${size}
       `);
     }
     function undisplayCalibrationTag() {
       ws.send(`
          Retract /anyone/ wishes to display CNC calibration tag with /...options/
       `);
     }
     function setCalibrationTagCameraCorners(corners) {
       window.corners = corners;
       moveCalibrationTagCameraCornersDiv.innerHTML =
         `<ol>` +
         corners.map(corner =>
           `<li><code>[${corner[0].toFixed(2)}, ${corner[1].toFixed(2)}]</code></li>`
         ).join("\n") +
         `</ol>`;
     }
    </script>

    <ol>
      <li id="displayCalibrationTagListItem">
        Display calibration tag on projector:
        <button id="displayCalibrationTagButton">Display Calibration Tag</button>
      </li>
      <script>
       function stepDisplayCalibrationTag() {
         displayCalibrationTagButton.addEventListener('click', (e) => {
           ws = new WebSocket(window.location.origin.replace("http", "ws") + "/ws");
           ws.onopen = () => {
             redisplayCalibrationTag();
             doneDisplayCalibrationTag();
           };
           ws.onclose = () => {
             document.body.style.background = 'red';
           };
           ws.onerror = (err) => {
             document.body.style.background = 'red';
             console.error('Socket encountered error: ', err.message, 'Closing socket');
             ws.close();
           }
           ws.onmessage = (msg) => { eval(msg.data); };
           window.onbeforeunload = () => { undisplayCalibrationTag(); };
         });
       }
       function doneDisplayCalibrationTag() {
         displayCalibrationTagListItem.style.textDecoration = 'line-through';
         displayCalibrationTagButton.style.textDecoration = 'line-through';
         stepMoveCalibrationTag();
       }
      </script>

      <li id="moveCalibrationTagListItem" style="display: none">
        Move calibration tag so it's on the surface of the material:
        <div class="container" style="background: #eee; width: 320px; height: 240px">
          <div class="movable"
            style="background: #444;
                      font-family: sans-serif;
                      text-align: center;
                      user-select: none;
                      position: relative;
                      cursor: move;
                      overflow: hidden;
                      color: #eee">
            <b>Drag</b> me + <b>resize</b> from the resize corner
            <div class="resize-handle"
              style="position: absolute; right: 0; bottom: 0;
                        width: 15px; height: 15px;
                        background: #c44;
                        cursor: nwse-resize"></div>
          </div>
        </div>
        <p>Camera corners: <div id="moveCalibrationTagCameraCornersDiv"></div></p>
        <button id="moveCalibrationTagDoneButton">Done (tag is on material)</button>
      </li>
      <script>
       function stepMoveCalibrationTag() {
         moveCalibrationTagListItem.style.display = "";

         function makeDraggable(state, el) {
           // from https://www.redblobgames.com/making-of/draggable/
           function start(event) {
             if (event.button !== 0) return; // left button only
             event.stopPropagation(); // for nested draggables
             let {x, y} = state.eventToCoordinates(event);
             state.dragging = {dx: state.pos.x - x, dy: state.pos.y - y};
             el.setPointerCapture(event.pointerId);
           }
           function end(_event) { state.dragging = null; }
           function move(event) {
             if (!state.dragging) return;
             event.stopPropagation(); // for nested draggables
             let {x, y} = state.eventToCoordinates(event);
             state.pos = {x: x + state.dragging.dx, y: y + state.dragging.dy};
           }

           el.addEventListener('pointerdown', start);
           el.addEventListener('pointerup', end);
           el.addEventListener('pointercancel', end);
           el.addEventListener('pointermove', move)
           el.addEventListener('touchstart', (e) => e.preventDefault());
         }
         const el = document.querySelector(".movable");
         let state = { x: 30, y: 10, size: 100 };

         function resizeAndPosition() {
           let {x, y, size} = state;
           el.style.transform = `translate(${x}px,${y}px)`;
           el.style.width = `${size}px`; el.style.height = `${size}px`;
           redisplayCalibrationTag(x, y, size);
         }

         let outerState = {
           eventToCoordinates(event) { return {x: event.clientX, y: event.clientY}; },
           dragging: false,
           get pos() { return {x: state.x, y: state.y}; },
           set pos(p) {
             const container = el.parentNode.getBoundingClientRect();
             const bounds = el.getBoundingClientRect();
             state.x = p.x;
             state.y = p.y;
             resizeAndPosition();
           },
         }

         let innerState = {
           eventToCoordinates(event) { return {x: event.clientX, y: event.clientY}; },
           dragging: false,
           get pos() { return {x: state.x + state.size, y: state.y + state.size}; },
           set pos(p) {
             state.size = Math.min(Math.max(40, p.x - state.x), Math.max(40, p.y - state.y));
             resizeAndPosition();
           },
         }
         resizeAndPosition();
         makeDraggable(outerState, el);
         makeDraggable(innerState, document.querySelector(".resize-handle"));

         moveCalibrationTagDoneButton.addEventListener("click", doneMoveCalibrationTag);
       }
       function doneMoveCalibrationTag() {
         moveCalibrationTagListItem.style.textDecoration = "line-through";
         moveCalibrationTagListItem.querySelector(".container").style.pointerEvents = "none";
         moveCalibrationTagDoneButton.style.textDecoration = "line-through";
         // TODO: do other mode switch stuff
         stepMoveTool();
       }
      </script>

      <li id="moveTool" style="display: none">
        TODO: Move the CNC machine (tool center point) to each of the 4 calibration tag corner points:
        <button id="moveToolDoneButton">Done</button>
      </li>
      <script>
       function stepMoveTool() {
         moveTool.style.display = "";
       }
      </script>
    </ol>

    <script>
     stepDisplayCalibrationTag();
    </script>
  </body>
</html>
    }
}

When the display /disp/ has width /displayWidth/ height /displayHeight/ &\
     /someone/ wishes to display CNC calibration tag with /...options/ {
    set id [dict get $options id]
    set tx [dict get $options x]; set ty [dict get $options y]
    set size [dict get $options size]

    set tagImage [::tagImageForId $id]
    set tagBits [list]
    # 10x10 AprilTag -> 100 bits
    for {set y 0} {$y < 10} {incr y} {
        for {set x 0} {$x < 10} {incr x} {
            set j [expr {$y * [image_t bytesPerRow $tagImage] + $x}]
            set bit [== [image_t data $tagImage $j] 255]
            lappend tagBits $bit
        }
    }
    # -> 4 32-bit integers
    set tagBitsVec [list 0b[join [lreverse [lrange $tagBits 0 31]] ""] \
                        0b[join [lreverse [lrange $tagBits 32 63]] ""] \
                        0b[join [lreverse [lrange $tagBits 64 95]] ""] \
                        0b[join [lreverse [lrange $tagBits 96 127]] ""]]

    set topLeft [list $tx $ty]
    set topRight [list [+ $tx $size] $ty]
    set bottomRight [list [+ $tx $size] [+ $ty $size]]
    set bottomLeft [list $tx [+ $ty $size]]
    Wish the GPU draws pipeline "apriltag" with arguments \
        [list $tagBitsVec $topLeft $topRight $bottomRight $bottomLeft] \
        layer 100

    Wish to draw a quad with \
        p0 [list 0 0] p1 [list $displayWidth 0] \
        p2 [list $displayWidth $displayHeight] p3 [list 0 $displayHeight] \
        color white layer 99
}

Wish the GPU compiles pipeline "apriltag" {
    {uvec4 tagBitsVec vec2 a vec2 b vec2 c vec2 d} {
        vec2 vertices[4] = vec2[4](a, b, d, c);
        return vertices[gl_VertexIndex];
    } {fn ::invBilinear} {
        vec2 p = gl_FragCoord.xy;
        vec2 uv = invBilinear(p, a, b, c, d);

        int x = int(uv.x * 10); int y = int(uv.y * 10);
        int bitIdx = y * 10 + x;
        uint bit = (tagBitsVec[bitIdx / 32] >> (bitIdx % 32)) & 0x1;
        return bit == 1 ? vec4(1, 1, 1, 1) : vec4(0, 0, 0, 1);
    }
}

When /chan/ wishes to display CNC calibration tag with /...options/ {
    When the clock time is /t/ {
        # Only report a new tag location to the web frontend every 100ms.
        Claim the CNC calibration tag time is [floor [* $t 10]]
    }

    set id [dict get $options id]
    When the CNC calibration tag time is /t/ &\
         tag $id has corners /corners/ {
        set cornersJs [concat {[} [join [lmap corner $corners {
            concat {[} [join $corner ","] {]}
        }] ", "] {]}]
        ::websocket::send $chan text "setCalibrationTagCameraCorners($cornersJs);"
    }
}
